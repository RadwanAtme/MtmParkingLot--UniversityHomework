2 חלק א – מימוש מבנה נתונים גנרי
1.2 תיאור כללי
בחלק זה של התרגיל נרצה לממש מבנה נתונים גנרי ב-++C תוך שימוש בתבניות )Templates)
וחריגות.
הערה: כיוון שבמועד פרסום התרגיל טרם נלמדו תבניות וחריגות )יילמדו בתרגול 10 ,)מומלץ בתור
התחלה לממש את הUniqueArray בצורה לא גנרית וללא חריגות )למשל עבור int בלבד( ולהפוך את
המימוש שלכם לגנרי/להוסיף חריגות לאחר לימוד הנושאים.
מבנה הנתונים אותו נממש נקרא UniqueArray ,והוא שילוב של מערך רגיל ו-Set שראיתם במהלך
הסמסטר:
1 .ל-UniqueArray כמות מקסימלית של איברים הנקבעת עם יצירתו )ולא משתנה עד הריסתו(,
בדומה למערך.
הפקולטה למדעי המחשב טכניון – מכון טכנולוגי לישראל
234124 מבוא לתכנות מערכות סמסטר חורף תש"פ
2
2 .הוספת איברים מתבצעת ע"י פעולת insert בדומה ל-Set .כל איבר המוכנס ל-UniqueArray
מקבל מספר סידורי )אינדקס, בדומה למערך(, אשר מוחזר כאשר האיבר מוכנס בהצלחה.
מספר זה אינו משתנה כל עוד האיבר נמצא ב-UniqueArray .אם מנסים להכניס איבר שכבר
קיים יוחזר האינדקס של האיבר הקיים )כל איבר יכול להופיע פעם אחת בלבד בדומה ל-
.)Set
3 .ניתן לקבל את המספר הסידורי של איבר ב UniqueArray-ע"י פעולת.getIndex
4 .נרצה לממש פעולת filter על ה-UniqueArray ,שתחזיר UniqueArray חדש בו יופיעו רק
האיברים העומדים בפילטר.
כאמור ה-UniqueArray ישתמש בתבניות. נרצה לספק לUniqueArray שני פרמטרי תבנית:
1 .Element Class – זהו טיפוס האלמנטים של ה-UniqueArray .שימו לב: אסור להניח כי ל-
Element יש בנאי חסר פרמטרים.
2 .Compare Class – זוהי פונקציה )או Object Function )אשר מממשת השוואה בין שני
אלמנטים ב-UniqueArray( נשתמש כפרמטר ברירת מחדל ב- <Element<to_equal::std
אשר מממש את ההשוואה הרגילה בין שני משתנים מטיפוס Element .ניתן למצוא תיעוד
מדויק של to_equal::std בקישור הבא:
.)https://en.cppreference.com/w/cpp/utility/functional/equal_to
UniqueArray-ה ממשק 2.2
הפעולות אותן עליכם לממש עבור ה-UniqueArray הינן:
1 .בנאי ליצירת UniqueArray:
UniqueArray(unsigned int size);
פרמטרים: size – הגודל המקסימלי של ה-UniqueArray
2 .בנאי העתקה ל-UniqueArray:
UniqueArray(const UniqueArray& other);
פרמטרים: other – ה-UniqueArray אותו יש להעתיק
3 .הורס ה-UniqueArray:
~UniqueArray();
4 .הוספת איבר ל-UniqueArray:
unsigned int insert(const Element& element);
פרמטרים: element – האלמנט אותו יש להוסיף ל-UniqueArray
ערך חזרה: - מספר סידורי פנוי כלשהו )במידה והאלמנט קיים יוחזר המספר הסידורי
הקיים(
חריגות: UniqueArrayIsFullException – במקרה והUniqueArray מלא ולא ניתן להוסיף
את האיבר
5 .פעולת החזרת המספר הסידורי של אלמנט ב-UniqueArray:
bool getIndex(const Element& element, unsigned int& index)
const;
פרמטרים: element – האלמנט ב-UniqueArray עבורו יש להחזיר את המספר הסידורי
הפקולטה למדעי המחשב טכניון – מכון טכנולוגי לישראל
234124 מבוא לתכנות מערכות סמסטר חורף תש"פ
3
index – רפרנס למשתנה אליו יש להחזיר את המספר הסידורי.
ערך חזרה: - true אם האלמנט נמצא, false אחרת. במידה והאלמנט נמצא מספרו הסידורי
יושם לתוך index.
6 .אופרטור ][ להחזרת אלמנט מתוך ה-UniqueArray:
const Element* operator[] (const Element& element) const;
פרמטרים: element – האלמנט ב-UniqueArray אותו יש להחזיר.
ערך חזרה: - מצביע לאלמנט ב-UniqueArray השווה לElement הנתון )לפי ה-Compare
הנתון בתבנית(. אם האלמנט לא קיים יוחזר מצביע NULL.
7 .הסרת אלמנט מה-UniqueArray:
bool remove(const Element& element);
פרמטרים: element – האלמנט אותו יש להסיר מה-UniqueArray
ערך חזרה: - true אם האלמנט הוסר, false אחרת
8 .פעולה להחזרת מספר האלמנטים הנוכחי ב-UniqueArray:
unsigned int count() const;
פרמטרים: -
ערך חזרה: מספר האלמנטים הנוכחי ב-UniqueArray
9 .פעולה להחזרת מספר האלמנטים המקסימלי ב-UniqueArray:
unsigned int size() const;
פרמטרים: -
ערך חזרה: מספר האלמנטים המקסימלי ב-UniqueArray.
:filter פעולת. 10
UniqueArray<Element, Compare> filter(const Filter& f) const;
פרמטרים: f – משתנה מטיפוס Filter המהווה טיפוס בסיס לFunctor שמקבל const
&Element ומחזיר bool( ראו סעיף 3.2 לפירוט(
ערך חזרה: מחזירה <Compare, Element<UniqueArray חדש בגודל זהה לנוכחי, אשר
מכיל רק את האיברים מה-UniqueArray הנוכחי )this )שעבורם f החזירה true .שימו לב
שהאינדקסים של האיברים ב-UniqueArray החדש יהיו זהים לאינדקסים ב-UniqueArray
הנוכחי.
3.2 דגשים למימוש
1 .תוגדר מחלקת עזר פנימית UniqueArrayIsFullException עבור הניסיון להוסיף איבר
לUniqueArray מלא.
2 .בקובץ h.UniqueArray הנתון לכם, מופיעה הכרזת מחיקה של ה- assignment-copy
:operator
UniqueArray& operator=(const UniqueArray&) = delete;
הפקולטה למדעי המחשב טכניון – מכון טכנולוגי לישראל
234124 מבוא לתכנות מערכות סמסטר חורף תש"פ
4
אם במימוש שלכם יש צורך באופרטור, אתם רשאים למחוק את הdelete =ולממשו. אחרת,
אין למחוק שורה זו.
3 .תוגדר מחלקת עזר פנימית Filter המהווה טיפוס בסיס אבסטרקטי לאובייקט פונקציה
שיממש את אופרטור )( הבא:
virtual bool operator() (const Element&) = 0;
כלומר זוהי פונקציה הבודקת קיום תנאי כלשהו על אלמנט של ה-UniqueArray.
4 .את ההכרזות עליכם לכתוב בקובץ h.UniqueArray( אשר מסופק לכם חלקית(. ניתן להוסיף
פעולות נוספות כראות עיניכם עם תיעוד מתאים.
5 .את המימוש עליכם לכתוב בקובץ h.UniqueArrayImp לו מבצעים include בתוך
h.UniqueArray .שימו לב: אין לבצע “h.UniqueArray “include בקובץ
!UniqueArrayImp.h
6 .אין להשתמש בSTL עבור מימוש ה-UniqueArray( פרט לברירת מחדל עבור פרמטר
התבנית Compare)
7 .הינכם יכולים להוסיף פעולות ממשק נוספות כראות עיניכם עבור המשך התרגיל – אך כמובן
שיש לשמור על ה-Encapsulation של המבנה.
8 .עליכם להניח שהמימוש שלכם יעבור בדיקות יחידה עבור כל אחת מהפעולות המוגדרות.
מסופק לכם קובץ בדיקה cpp.UniqueArrayTests שבודק התנהגות תקינה בסיסית של
הUniqueArray ,אך אין זה תחליף לבדיקות יחידה מקיפות ולכן אנו מעודדים אתכם לבנות
אותן בעצמכם כדי לוודא תקינות.
3 חלק ב – שאלות יבשות על ה-UniqueArray
עליכם לענות על השאלות הבאות ולהגישן בקובץ PDF בשם pdf.dry שיצורף ל-zip ההגשה הסופית.
1 .אילו דרישות צריכות להתקיים ע"י פרמטרי התבנית Element ו-Compare בהם אנו
משתמשים ב-UniqueArray?
2 .נניח כי היינו מגדירים ע"י overloading operator את האופרטור הבא, המקבל מספר סידורי
של איבר ב-UniqueArray ומחזיר את המצביע לאיבר:
const Element* operator[] (unsigned int index) const;
איזו בעיה עלולה להיווצר כעת בשימוש ב-UniqueArray ?כיצד ניתן להתגבר על הבעיה?
את הפתרון יש להגיש בקובץ PDF בשם pdf.dry ,שיצורף ל-zip של החלק הרטוב. מומלץ להשתמש
בתוכנת Word כדי לכתוב את הפתרון, ואז להשתמש ב-Export->File על מנת לייצא לקובץ PDF.
4 חלק ג – מימוש מערכת למגרש חניה MtmParkingLot
1.4 תיאור כללי
בחלק זה של התרגיל נממש מערכת עבור מגרש חניה. מטרת המערכת היא מעקב אחר
כניסה/יציאה של רכבים למגרש, הדפסת מידע בעת הצורך, וטיפול בתשלום בהתאם לזמן החניה
וסוג הרכב.
• ישנם 3 סוגי רכבים הנתמכים במערכת, והם יכולים לחנות באיזורי חניה ספציפיים
)"בלוקים"( בהתאם לסוג הרכב:
1 .אופנועים יכולים לחנות בבלוק חניות לאופנועים בלבד
2 .רכב פרטי רגיל יכול לחנות בבלוק לרכבים פרטיים בלבד
3 .רכב של אדם נכה יכול לחנות בבלוק חניית נכים )בעדיפות ראשונה(, ובמידה והיא
מלאה גם בבלוק של רכבים פרטיים.
הפקולטה למדעי המחשב טכניון – מכון טכנולוגי לישראל
234124 מבוא לתכנות מערכות סמסטר חורף תש"פ
5
• מספר החניות בכל בלוק חניה )עבור אופנוע/רכב רגיל/חניות נכים( נקבע מראש בעת יצירת
מבנה מגרש החניה
• תשלום של כל רכב נקבע לפי סוג הרכב וזמן החניה, בהתאם לחוקים הבאים:
o אופנוע ישלם 10 ש"ח עבור שעת חניה ראשונה או חלק ממנה, ו-5 ש"ח עבור כל
שעת חניה נוספת או חלק ממנה, וישלם לכל היותר על 6 שעות. לדוגמא:
▪ אופנוע שחנה במשך 3 דקות ישלם 10 ש"ח
▪ אופנוע שחנה במשך שעה )60 דקות( ישלם 10 ש"ח
▪ אופנוע שחנה במשך שעה ודקה ישלם 15 ש"ח
▪ אופנוע שחנה במשך 15 שעות ישלם 35 ש"ח )מחיר של 6 שעות(
o רכב פרטי רגיל ישלם כמו אופנוע, אך 20 ש"ח עבור שעה ראשונה ו-10 ש"ח עבור
שעות נוספות )ולכל היותר על 6 שעות(.
o רכב נכה ישלם 15 ש"ח קבוע, ללא תלות בזמן החניה. לדוגמא:
▪ רכב נכה שחנה במשך 3 דקות ישלם 15 ש"ח
▪ רכב נכה שחנה במשך 5 שעות ישלם 15 ש"ח
▪ שימו לב שהמחיר עבור רכב נכה לא תלוי באם הוא חנה בחניית נכים או
בחניית רכב רגיל.
• חניית כל הרכבים במגרש החניה מוגבלת ל-24 שעות מרגע כניסתם. מדי פעם מגיע למגרש
החניה פקח, כך שכל הרכבים שחונים יותר מ-24 שעות יקבלו קנס של 250 ש"ח, אותו
ישלמו בזמן היציאה בנוסף לתשלום הרגיל על החניה. שימו לב שהקנס אינו תלוי בסוג
הרכב. כמו כן כל רכב יכול להיקנס לכל היותר פעם אחת.
• על המערכת לתמוך בפעולות של:
1 .כניסת רכב למגרש החניה
2 .יציאה ותשלום של רכב ממגרש החניה
3 .הגעת הפקח למגרש החניה
4 .הדפסת כל הרכבים במגרש החניה
2.4 מבנה המערכת
בחלק זה של התרגיל עליכם לממש את מחלקת ParkingLot שתיאורה מובא מיד. במידת הצורך רצוי
)ומומלץ( להגדיר מחלקות עזר נוספות. כמו כן עומדים לרשותכם מספר טיפוסים/מחלקות/קבועים
אותן הגדיר סגל הקורס, שתיאורן יובא בהמשך.
ParkingLot מחלקת 4.2.1
זוהי מחלקה המייצגת את המבנה של מגרש החניה. עליכם לממש עבור מגרש החניה את הפעולות
הבאות:
1 .בנאי ליצירת ParkingLot חדש:
ParkingLot(unsigned int parkingBlockSizes[]);
פרמטרים: מערך של מספר מקומות החניה לכל סוג רכב, כאשר סדר האיברים לפי הערכים
)Car=2 ,HandicappedCar=1 ,Motorbike=0 כלומר )VehicleType של המספריים
:ParkingLot הורס. 2
~ParkingLot();
פרמטרים: -
3 .פעולה להכנסת רכב למגרש החניה, בהתאם לחוקים ב-1.4 ,והדפסת הודעה מתאימה:
ParkingResult enterParking(VehicleType vehicleType,
LicensePlate licensePlate, Time entranceTime);
הפקולטה למדעי המחשב טכניון – מכון טכנולוגי לישראל
234124 מבוא לתכנות מערכות סמסטר חורף תש"פ
6
פרמטרים: vehicleType – סוג הרכב הנכנס
licensePlate – לוחית רישוי של הרכב הנכנס
entranceTime – זמן הכניסה של הרכב
ערך חזרה ופעולה: יוחזר משתנה מטיפוס ParkingResult המוגדר כחלק מהטיפוסים
הנתונים )ראו 3.4 לפרטים(, ויודפסו הודעות בהתאם לחוקיות הבאה:
a .עבור כניסה מוצלחת, תתבצע הדפסה של הרכב ע"י מתודת
printVehicle::ParkingLotPrinter והדפסת כניסה מוצלחת ע"י מתודת
printEntrySuccess::ParkingLotPrinter( בסדר הזה(. המתודות מוגדרות במחלקת
ParkingLotPrinter המסופקת לכם )ראו 3.4 .)יוחזר SUCCESS.
b .כאשר אין מקום חניה לרכב, תתבצע הדפסה של הרכב והדפסת כניסה לא מוצלחת
ע"י מתודת parkingEntryFailureNoSpot::ParkingLotPrinter .יוחזר
.NO_EMPTY_SPOT
c .כאשר הרכב המוכנס כבר נמצא במגרש החניה תתבצע הדפסה של הרכב )הקיים(
והדפסה ע"י מתודת parkingEntryFailureAlreadyParked::ParkingLotPrinter.
.ALREADY_PARKED יוחזר
4 .פעולה להוצאת רכב ממגרש החניה, והדפסת הודעה מתאימה:
ParkingResult exitParking(LicensePlate licensePlate, Time
exitTime);
פרמטרים: licensePlate – לוחית רישוי של הרכב היוצא
exitTime – זמן היציאה של הרכב
ערך חזרה ופעולה: יוחזר משתנה מטיפוס ParkingResult המוגדר כחלק מהטיפוסים
הנתונים )ראו 3.4 לפרטים(, ויודפסו הודעות בהתאם לחוקיות הבאה:
a .עבור יציאה מוצלחת של הרכב, תתבצע הדפסה של הרכב ע"י
printVehicle:ParkingLotPrinterוהדפסת יציאה מוצלחת ע"י מתודת
SUCCESS.יוחזרParkingLotPrinter::parkingExitSuccess.
b .עבור יציאה לא מוצלחת של הרכב )הרכב לא נמצא במגרש החניה(, תודפס הודעה
ע"י מתודת parkingExitFailure::ParkingLotPrinter .יוחזר
.VEHICLE_NOT_FOUND
5 .פעולה לקבלת מקום החניה של רכב:
ParkingResult getParkingSpot(LicensePlate licensePlate,
ParkingSpot& parkingSpot) const;
פרמטרים: licensePlate – לוחית הרישוי של הרכב
parkingSpot – משתנה ParkingSpot אליו יש להחזיר את חניית הרכב במידה והרכב נמצא
במגרש החניה.
ערך חזרה: ParkingResult בהתאם לתוצאה:
a .SUCCESS – במידה והרכב נמצא, מיקום החניה שלו יושם לתוך משתנה
.parkingSpot
b .FOUND_NOT_VEHICLE – במידה והרכב בעל לוחית הרישוי לא נמצא במגרש.
6 .אופרטור הדפסה של מגרש החניה:
הפקולטה למדעי המחשב טכניון – מכון טכנולוגי לישראל
234124 מבוא לתכנות מערכות סמסטר חורף תש"פ
7
friend ostream& operator<<(ostream& os, const ParkingLot&
parkingLot);
פרמטרים: os – הstream לתוכו יש להדפיס
parkingLot – מגרש החניה אותו נרצה להדפיס
ערך חזרה: os – הstream לאחר ההדפסה.
אופן פעולה: תחילה יש לקרוא למתודת printParkingLotTitle::ParkingLotPrinter על מנת
להדפיס כותרת, לאחר מכן עבור כל רכב יש לבצע:
a .הדפסת רכב ע"י מתודת printVehicle::ParkingLotPrinter
b .קריאה למתודת printParkingSpot::ParkingLotPrinter ,המקבלת כפרמטר
משתנה מטיפוס ParkingSpot המוגדר לכם )ראו 3.4 לפרטים(. שימו לב
שמתודה זו כבר כוללת ירידת שורה כך שאין צורך לכלול ירידת שורה נוספת.
סדר הדפסת הרכבים יהיה ממוין לפי ה-ParkingSpot שלהם. ניתן להשתמש ב-STL עבור
המיון )שימו לב שלמחלקת ParkingSpot כבר מוגדר אופרטור השוואה(.
7 .פעולת ביקור הפקח:
void inspectParkingLot(Time inspectionTime);
פרמטרים: inspectionTime – שעת הגעת הפקח
אופן פעולה: יש למצוא את כל הרכבים בחניון החונים יותר מ-24 שעות בזמן ביקור הפקח.
עבור כל רכב כזה יש לסמנו כך שישלם קנס של 250 ש"ח הנוסף על התשלום הרגיל בזמן
היציאה. כמו כן תתבצע קריאה למתודת printInspectionResult::ParkingLotPrinter
המקבלת כפרמטר את זמן ביקור הפקח ומספר הרכבים שנקנסו ומדפיסה הודעה מתאימה.
2.2.4 דגשים לגבי המימוש
• נתון לכם קובץ Header עבור מחלקת ParkingLot ,עליכם להשלים אותו ולהוסיף קובץ cpp
מתאים.
• אלא אם נאמר אחרת, מותר לכם להוסיף פעולות/מחלקות עזר, אך כמובן שיש לשמור על
Encapsulation ולתעד כל מחלקה/פעולה אותה אתם מוסיפים.
• עבור הדפסות, אין לשנות את פורמט ההדפסה. בפרט אין צורך להוסיף הדפסות של
מחרוזות משלכם )כולל רווחים/תווי סוף שורה(. יש להשתמש בפונקציות שנתונות לכם
במחלקת ParkingLotPrinter.
• חישבו היטב על איך לייצג את הרכבים ב-ParkingLot ,כיצד להקצות להם ParkingSpot
וכיצד לממש את חוקי כניסת הרכבים.
• מותר ורצוי להשתמש ב-UniqueArray שהגדרתם בחלק א.
• מותר להשתמש בSTL בחלק זה של התרגיל.
• ניתן להניח שהקריאה למתודות ה-ParkingLot מתבצעת בסדר כרונולוגי – כלומר לא ייתכן
שנקרא לexitParking עבור רכב עם זמן יותר קטן מזמן כניסתו.
• יש לממש את כל המחלקות שלכם תחת MtmParkingLot namespace
• עליכם להניח שהמימוש שלכם יעבור בדיקות יחידה עבור כל אחת מהפעולות המוגדרות
)מלבד בדיקות קלט/פלט המסופקות לכם עבור תכנית MtmParkingLot.)
3.4 הגדרות וטיפוסים נתונים
להלן פירוט ההגדרות של הטיפוסים הנתונים לכם איתם אתם יכולים לממש את המערכת. אין צורך
לממש מחדש טיפוסים אלו!
הפקולטה למדעי המחשב טכניון – מכון טכנולוגי לישראל
234124 מבוא לתכנות מערכות סמסטר חורף תש"פ
8
כל הטיפוסים המוגדרים בסעיפים הבאים נמצאים תחת ParkingLotUtils namespace.
שימו לב! אין לשנות את הטיפוסים/מחלקות/קבועים הנתונים לכם. אתם לא מגישים קבצים אלו
והקוד שלכם יקומפל עם עותק של הקבצים האלו מהשרת.
Time מחלקת 4.3.1
זוהי מחלקה המממשת ADT של זמן עבור מערכת מגרש החניה, בה הינכם צריכים להשתמש כדי
לקבל זמני כניסה ויציאה של רכבים ולחשב זמני חניה ועלויות. תיאור הפעולות נמצא בקובץ h.Time
המסופק לכם.
ParkingSpot מחלקת 4.3.2
זוהי מחלקה המממשת ADT של מיקום חניה )בלוק + מס' סידורי(. עליכם להשתמש במחלקה זו על
מנת להחזיר מיקום חניה של רכב במתודת getParkingSpot ,וכמו כן עליכם להדפיס את מגרש
החניה ממוין לפי ה-ParkingSpot של כל רכב. תיאור הפעולות נמצא בקובץ h.ParkingLot המסופק
לכם.
ParkingLotPrinter מחלקת 4.3.3
זוהי מחלקת עזר המספקת לכם פעולות סטטיות עבור כל ההדפסות במערכת. תיאור הפעולות נמצא
בקובץ h.ParkingLotPrinter המסופק לכם.
ParkingLotTypes.h קובץ 4.3.4
זהו קובץ header המכיל הגדרות טיפוסים נוספים אותם אתם תצטרכו עבור התרגיל )שאינם
מחלקות(. ניתן לעשות Include לקובץ זה בכל מקום בקוד בו יש צורך. הקובץ מכיל את ההגדרות
הבאות:
1 .הגדרת טיפוס LicensePlate עבור לוחית הרישוי של כל רכב )מוגדר להיות string.)
2 .ParkingResult Enum – מגדיר תוצאות אפשריות של פעולות על מגרש החניה:
a .SUCCESS – הצלחת הפעולה
b .SPOT_EMPTY_NO – אין מקום חניה לרכב
c .FOUND_NOT_VEHICLE – הרכב לא נמצא במגרש החניה
d .PARKED_ALREADY_VEHICLE – הרכב כבר חונה במגרש החניה
3 .VehicleType Enum – מגדיר את סוגי הרכבים האפשריים במערכת:
אופנוע – MOTORBIKE .a
b .HANDICAPPED – רכב נכה
c .CAR – רכב רגיל
d .FIRST – מכיל את הערך של סוג הרכב הראשון בטיפוס )MOTORBIKE)
e .LAST – מכיל את הערך של סוג הרכב האחרון בטיפוס )CAR)
MtmParkingLot.cpp קובץ 4.3.5
קובץ זה מכיל את המעטפת לתכנית. בקובץ זה קיימת פונקציית ה-main של התכנית ותפקידו לקבל
קלט מהמשתמש )בין אם בקובץ/הקלדה לתוך cin )ולהשתמש במחלקת ParkingLot שמימשתם על
מנת לסמלץ את מגרש החניה. השימוש בתכנית יהיה מהצורה הבאה:
./MtmParkingLot [inputFile]
אופן פעולת התכנית הוא כלהלן:
1 .פתיחת ה-stream input – כלומר במידה והמשתמש נתן קובץ קובץ קלט אז נפתח אותו
לקריאה, אחרת נשתמש ב-cin.
2 .אתחול הזמן הנוכחי )ל-0 )ואתחול מגרש החניה
הפקולטה למדעי המחשב טכניון – מכון טכנולוגי לישראל
234124 מבוא לתכנות מערכות סמסטר חורף תש"פ
9
3 .מעבר על פקודות המשתמש
4 .סגירת ה-stream input( במידת הצורך( וסיום התכנית. כדי לצאת מהתכנית כאשר אנו
קולטים קלט מ-cin יש לכתוב EOF( D+Ctrl ,)אחרת התכנית תסיים לרוץ לאחר שכל
הפקודות מהקובץ בוצעו )הגענו לEOF בקובץ הקלט(.
הפקודות המותרות בתכנית הינן:
1> .LicensePlate> <VehicleType <ENTER - פקודה להכנסת רכב בעל לוחית רישוי > License
Plate >למגרש חניה. <Type Vehicle <יכול לקבל אחד מהערכים: } ,Motorbike
.}Handicapped, Car
2> .LicensePlate <EXIT - פקודה להוצאת רכב ממגרש החניה
3 .INSPECT – פקודה לביקור הפקח
4 .PRINT – פקודה להדפסת מגרש החניה
5> .mins of <# TIME_PASS - מזיזה את הזמן הנוכחי קדימה במספר הדקות הנתון.
לאחר שסיימתם לממש את המחלקות שעליכם לממש, יש לקמפל את התכנית ולהריץ אותה על קבצי
הקלט הנתונים לכם תחת .txt*.input/files_io הפלט המצופה אמור להתאים לקובץ
txt*.output/files_io( למעט מקרים מסוימים, ראו הערה למטה(. קיימת אפשרות לבדוק את
ההתאמה בצורה אוטומטית ע"י סקריפט שמסופק לכם) py.check_final פרטים בסעיף 5 .)אנו
מעודדים אתכם לא להסתפק בקבצים אלו בלבד ולהוסיף בדיקות נוספות בעצמכם.
הערה: עקב חופש הבחירה שיש בידיכם במימוש הקצאת המספר הסידורי ב UniqueArray
והקצאת מספרי החניות לרכבים ב-ParkingLot יתכנו הבדלים בין הפלט של התכנית שלכם
לקבצי הפלט המסופקים - במספרי החניה של הרכבים ובסדר הדפסתם בפעולת Print .הבדלים
כאלה לא בהכרח מעידים כי המימוש שלכם אינו נכון, והמימוש בכל מקרה ייבדק בבדיקות
המתייחסות למקרים האלו )מטרת קבצי הקלט/פלט היא רק לתת לכם הערכה לנכונות המימוש(.
אנו מעודדים אתכם לבדוק את המימוש שלכם בבדיקות יחידה משלכם ולא להסתמך על בדיקות
הקלט/פלט בלבד.
4.4 דרישות נוספות לחלק הרטוב
Makefile 4.4.1
עליכם לספק Makefile כמו שנלמד בקורס עבור בניית הקוד של חלק ב של התרגיל. הכללים
המינימליים שצריכים להופיע ב-Makefile הינם:
• כלל MtmParkingLot שיבנה את התכנית MtmParkingLot
• כלל לכל ADT שהוספתם בחלק ב של התרגיל
• כלל clean אשר מוחק את כל תוצרי הקימפול
הידור 4.4.2
התרגיל ייבדק על שרת csl3 ועליו לעבור הידור בעזרת הפקודה הבאה:
g++ -std=c++11 -Wall -Werror -pedantic-errors –DNDEBUG -o
MtmParkingLot *.cpp
כמו כן ייבדק בנפרד מימוש ה-UniqueArray ,עליו לעבור הידור בעזרת הפקודה הבאה:
g++ -std=c++11 -Wall -Werror -pedantic-errors -g
tests/UniqueArrayTest.cpp -o UniqueArrayTest
עליכם לוודא שהרצה של פקודות אלו על csl3 אכן יוצרת את התוכניות הנדרשות מכם.
הפקולטה למדעי המחשב טכניון – מכון טכנולוגי לישראל
234124 מבוא לתכנות מערכות סמסטר חורף תש"פ
10
3.4.4 ולגרינד ודליפות זיכרון
המערכת חייבת לשחרר את כל הזיכרון שעמד לרשותה בעת ריצתה. על כן עליכם להשתמש ב-
valgrind שמתחקה אחר ריצת התוכנית שלכם, ובודק האם ישנם משאבים שלא שוחררו. הדרך
לבדוק האם יש לכם דליפות בתוכנית היא באמצעות שתי הפעולות הבאות )שימו לב שחייב להיות
main ,כי מדובר בהרצה ספציפית(:
1 .קימפול של השורה לעיל עם הדגל g-
2 .הרצת השורה הבאה:
valgrind --leak-check=full ./MtmParkingLot
כאשר MtmParkingLot זה שם קובץ ההרצה.
הפלט ש-valgrind מפיק אמור לתת לכם, במידה שיש לכם דליפות, את שרשרת הקריאות שהתבצעו
שגרמו לדליפה. אתם אמורים באמצעות דיבוג להבין היכן היה צריך לשחרר את אותו משאב שהוקצה
ולתקן את התוכנית. בנוסף, valgrind מראה דברים נוספים כמו קריאה לא חוקית )למשל קריאה
לזיכרון שכבר שוחרר( – גם שגיאות אלו עליכם להבין מהיכן מגיעות ולתקן.
התרגיל בדיקת 4.4.4
התרגיל ייבדק בדיקה יבשה )מעבר על קונבנציות הקוד והארכיטקטורה( ובדיקה רטובה.
הבדיקה היבשה כוללת מעבר על הקוד ובודקת את איכות הקוד )שכפולי קוד, קוד מבולגן, קוד לא
ברור, שימוש בטכניקות תכנות "רעות"(.
הבדיקה הרטובה כוללת את הידור התוכנית המוגשת והרצתה במגוון בדיקות אוטומטיות. על מנת
להצליח בבדיקה שכזו, על התוכנית לעבור הידור, לסיים את ריצתה, ולתת את התוצאות הצפויות.
5 אופן ההגשה
את ההגשה יש לבצע דרך אתר הקורס, תחת Submit Electronic -> HW3 -> Assignments .הקפידו
על הדברים הבאים:
- יש להגיש את קבצי הקוד מכווצים לקובץ zip( לא פורמט אחר(, כאשר כל הקבצים מופיעים
בתיקיית השורש בתוך קובץ ה-zip.
- יש להגיש אך ורק את קבצי ה-h וה-cpp אשר נדרשתם לכתוב/לשנות. אין להגיש את
הקבצים אשר סופקו לכם.
- הקבצים אשר מסופקים לכם יצורפו על ידינו במהלך הבדיקה. בפרט, ניתן להניח את קיום
ParkingLotPrinter.cpp, ParkingLotPrinter.h, Time.cpp, Time.h, ParkingSpot.cpp קבצי
h.ParkingLotTypes, h.ParkingSpot בתקייה הראשית, את קיום תקיית tests עם קובץ
cpp.UniqueArrayTest בתוכה, ואת קיום תקיית files_io עם )לפחות( הקבצים הנתונים לכם
בתוכה.
- ניתן להגיש את התרגיל מספר פעמים, רק ההגשה האחרונה נחשבת.
- על מנת לבטח את עצמכם נגד תקלות בהגשה האוטומטית, שמרו את קוד האישור עבור
ההגשה. עדיף לשלוח גם לשותף. כמו כן שמרו עותק של התרגיל של חשבון ה-csl3 שלכם
לפני ההגשה האלקטרונית ואל תשנו אותו לאחריה )שני הקובץ יגרור שינוי חתימת העדכון
האחרון(.
o כל אמצעי אחר לא ייחשב הוכחה לקיום הקוד לפני ההגשה.
לנוחותכם, אנו מספקים סקריפט בשם py.finalcheck לשימושכם לצורך וידוא תקינות ההגשה.
הסקריפט מוודא שה-zip מכיל רק את הקבצים הנדרשים, ומנסה להדר את הקוד ולהריץ אותו על
קבצי הבדיקה הנתונים )כלומר מנסה להריץ את UniqueArrayTest וכמו כן על הקבצים תחת
files_io .)להרצת הסקריפט, הריצו את השורה הבאה )כאשר zip.sol_ex3 הוא ה-zip שאתם עומדים
להגיש(:
~mtmchk/public/1920a/ex3/finalcheck.py ex3_sol.zip
זכרו, הסקריפט הוא לצורכי נוחות בלבד, וזו עדיין אחריותכם לוודא שההגשה עומדת בכל התנאים.